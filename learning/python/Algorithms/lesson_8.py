"""
Продлжение рекусрсии.
Задача генерации всех перестановок.
n- чисел от 1 до n- числа которые требуется переставлять.
Перестановок n числе существует n*(n-1)*...*2*1 = n! (n-факториал)
Как выдать эти самые перстановки?! Как сгененрировать?
При помощи рекусрии.

Сгенерируем n возможные чисел в системе счисления n..10
Генерируем от 000...0 до числа n-1...n-1 Длиной М

М-Длина числа
N- основание исчисления
Префикс- обощаем задачу, начинающейся с ничего (None)
Большую задачу генераци сокращается длинна оставшейся части, которую нужно генерировать.
Сгенерировать пвсе перестановки которые начинаются префиксом, с добавлением этой цифры:
"""


def gen_number(
        N: int,
        M: int,
        prefix=None
):
    '''
    Генерирут все числа (с лидирующими незначащими нулями
    в N-ричной системе счисления (N<=10) длины М.
    :param N: основание исчисления
    :param M: Длина числа
    :param prefix:
    :return:
    '''
    if M == 0:
        print(prefix)
        return
    prefix = prefix or []
    # Без доп. расхода памяти
    # Рекурентный случай:
    for digit in range(N):
        prefix.append(digit)
        gen_number(N, M - 1, prefix)  # задача упрощается за счёт уменьшения количества цифр
        prefix.pop()


def find_in(number, A):
    """
    Ищет number в A и возвращает True, если такой есть и наоборот

    :param number:
    :param A: списк, где нужно найти number
    :return:
    """
    for X in A:
        if number == X:
            return True
    return False


def gen_permutations(N: int, M: int = -1, prefix=None):
    """
    Генерация всех перестановок N чисел в M позициях, начиная с префикса prefix
    :param N:
    :param M:
    :param prefix:
    :return:
    """
    M = N if M == -1 else M  # по умолчанию N чиселв N позициях
    prefix = prefix or []
    if M == 0:
        print(*prefix, sep='')
        return
    for number in range(1, N + 1):
        if find_in(number, prefix):
            continue
        prefix.append(number)
        gen_permutations(N, M - 1, prefix)
        prefix.pop()

'''
Рекуретные сортировки. Сортировка Тони Хоара (Быстрая сортировка) и Сортировка слиянием.

Сортировка Тони Хоара (Быстрая сортировка).
На средней выборке сортировка происходит W(N log2N)
Не всегда работает хорошо.
Сортирует до О(N^2)
Выполняет сортирующее действие выполняется на :
1)Прямом ходу рекурсии. 
2)Обратном ходу рекурсии
Может выфполняться без дополнительной памяти.
Это алгоритм "разделяй и властвуй"
Суть:
Любой элемент- барьерный элемент. 
[4, 2, 6, 3, 1, 4, 5]
Возникает 3 группы элементов:
1)Те, кто равны барьеру: 4, 4
2)Те, кто ниже барьера: 2, 3, 1 
3)Те, кто выше барьера: 6, 5
Мы выполнили сортировочное действие, но не до конца, поскольку 1)  уже отсортирован, а 2) и 3) нет
Задача упрощается. Новые массивы 2) и 3) меньше, чем исходный.


Сортировка слиянием.
[4, 2, 6, 3, 1, 4, 5]
Часть А от 0 до N/2 не включительно
2 Часть А от N/2 включ, до N включ.

Первая итерация сортирует 2, 4, 6
Вторая 1, 3, 4, 5.

Дальше новый массив, берём 2 индекса из двух частей.
Тот, кто меньше идёт в новый список. Тот кто ниже из 2 списка и идёт в новый список и .т.д.
2 и 1? 1 меньше- идёт в новый список
2 и 3? 2 меньше- идёт в новый список
4 и 4? из первой части 4 в новый список
6 и 4? 4 идёт в новый список
6 и 5? 5 идёт в новый список
6 осталась в первой части
весь список с оставшимся 6- пихаем в самый конец- слияние 2 отсортированных массивов в 1.
'''

# if __name__ == "__main__":
    # gen_permutations(3)
    # gen_number(3, 3) # для произвольной СC
